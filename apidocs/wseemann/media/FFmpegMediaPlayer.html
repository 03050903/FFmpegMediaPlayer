<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_65) on Sat Apr 05 21:37:45 CDT 2014 -->
<TITLE>
FFmpegMediaPlayer
</TITLE>

<META NAME="date" CONTENT="2014-04-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="FFmpegMediaPlayer";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../wseemann/media/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnBufferingUpdateListener.html" title="interface in wseemann.media"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?wseemann/media/FFmpegMediaPlayer.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="FFmpegMediaPlayer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
wseemann.media</FONT>
<BR>
Class FFmpegMediaPlayer</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>wseemann.media.FFmpegMediaPlayer</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>FFmpegMediaPlayer</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
MediaPlayer class can be used to control playback
 of audio/video files and streams. An example on how to use the methods in
 this class can be found in <CODE>android.widget.VideoView</CODE>.

 <p>Topics covered here are:
 <ol>
 <li><a href="#StateDiagram">State Diagram</a>
 <li><a href="#Valid_and_Invalid_States">Valid and Invalid States</a>
 <li><a href="#Permissions">Permissions</a>
 <li><a href="#Callbacks">Register informational and error callbacks</a>
 </ol>

 <div class="special reference">
 <h3>Developer Guides</h3>
 <p>For more information about how to use MediaPlayer, read the
 <a href="../..guide/topics/media/mediaplayer.html">Media Playback</a> developer guide.</p>
 </div>

 <a name="StateDiagram"></a>
 <h3>State Diagram</h3>

 <p>Playback control of audio/video files and streams is managed as a state
 machine. The following diagram shows the life cycle and the states of a
 MediaPlayer object driven by the supported playback control operations.
 The ovals represent the states a MediaPlayer object may reside
 in. The arcs represent the playback control operations that drive the object
 state transition. There are two types of arcs. The arcs with a single arrow
 head represent synchronous method calls, while those with
 a double arrow head represent asynchronous method calls.</p>

 <p><img src="../../../images/mediaplayer_state_diagram.gif"
         alt="MediaPlayer State diagram"
         border="0" /></p>

 <p>From this state diagram, one can see that a MediaPlayer object has the
    following states:</p>
 <ul>
     <li>When a MediaPlayer object is just created using <code>new</code> or
         after <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#reset()"><CODE>reset()</CODE></A> is called, it is in the <em>Idle</em> state; and after
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#release()"><CODE>release()</CODE></A> is called, it is in the <em>End</em> state. Between these
         two states is the life cycle of the MediaPlayer object.
         <ul>
         <li>There is a subtle but important difference between a newly constructed
         MediaPlayer object and the MediaPlayer object after <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#reset()"><CODE>reset()</CODE></A>
         is called. It is a programming error to invoke methods such
         as <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#getCurrentPosition()"><CODE>getCurrentPosition()</CODE></A>,
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#getDuration()"><CODE>getDuration()</CODE></A>, <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#getVideoHeight()"><CODE>getVideoHeight()</CODE></A>,
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#getVideoWidth()"><CODE>getVideoWidth()</CODE></A>, <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setAudioStreamType(int)"><CODE>setAudioStreamType(int)</CODE></A>,
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setLooping(boolean)"><CODE>setLooping(boolean)</CODE></A>,
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setVolume(float, float)"><CODE>setVolume(float, float)</CODE></A>, <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#pause()"><CODE>pause()</CODE></A>, <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#start()"><CODE>start()</CODE></A>,
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#stop()"><CODE>stop()</CODE></A>, <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#seekTo(int)"><CODE>seekTo(int)</CODE></A>, <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepare()"><CODE>prepare()</CODE></A> or
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepareAsync()"><CODE>prepareAsync()</CODE></A> in the <em>Idle</em> state for both cases. If any of these
         methods is called right after a MediaPlayer object is constructed,
         the user supplied callback method OnErrorListener.onError() won't be
         called by the internal player engine and the object state remains
         unchanged; but if these methods are called right after <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#reset()"><CODE>reset()</CODE></A>,
         the user supplied callback method OnErrorListener.onError() will be
         invoked by the internal player engine and the object will be
         transfered to the <em>Error</em> state. </li>
         <li>It is also recommended that once
         a MediaPlayer object is no longer being used, call <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#release()"><CODE>release()</CODE></A> immediately
         so that resources used by the internal player engine associated with the
         MediaPlayer object can be released immediately. Resource may include
         singleton resources such as hardware acceleration components and
         failure to call <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#release()"><CODE>release()</CODE></A> may cause subsequent instances of
         MediaPlayer objects to fallback to software implementations or fail
         altogether. Once the MediaPlayer
         object is in the <em>End</em> state, it can no longer be used and
         there is no way to bring it back to any other state. </li>
         <li>Furthermore,
         the MediaPlayer objects created using <code>new</code> is in the
         <em>Idle</em> state, while those created with one
         of the overloaded convenient <code>create</code> methods are <em>NOT</em>
         in the <em>Idle</em> state. In fact, the objects are in the <em>Prepared</em>
         state if the creation using <code>create</code> method is successful.
         </li>
         </ul>
         </li>
     <li>In general, some playback control operation may fail due to various
         reasons, such as unsupported audio/video format, poorly interleaved
         audio/video, resolution too high, streaming timeout, and the like.
         Thus, error reporting and recovery is an important concern under
         these circumstances. Sometimes, due to programming errors, invoking a playback
         control operation in an invalid state may also occur. Under all these
         error conditions, the internal player engine invokes a user supplied
         OnErrorListener.onError() method if an OnErrorListener has been
         registered beforehand via
         <CODE>#setOnErrorListener(android.media.MediaPlayer.OnErrorListener)</CODE>.
         <ul>
         <li>It is important to note that once an error occurs, the
         MediaPlayer object enters the <em>Error</em> state (except as noted
         above), even if an error listener has not been registered by the application.</li>
         <li>In order to reuse a MediaPlayer object that is in the <em>
         Error</em> state and recover from the error,
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#reset()"><CODE>reset()</CODE></A> can be called to restore the object to its <em>Idle</em>
         state.</li>
         <li>It is good programming practice to have your application
         register a OnErrorListener to look out for error notifications from
         the internal player engine.</li>
         <li>IllegalStateException is
         thrown to prevent programming errors such as calling <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepare()"><CODE>prepare()</CODE></A>,
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepareAsync()"><CODE>prepareAsync()</CODE></A>, or one of the overloaded <code>setDataSource
         </code> methods in an invalid state. </li>
         </ul>
         </li>
     <li>Calling
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setDataSource(java.io.FileDescriptor)"><CODE>setDataSource(FileDescriptor)</CODE></A>, or
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setDataSource(java.lang.String)"><CODE>setDataSource(String)</CODE></A>, or
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setDataSource(Context, Uri)"><CODE>setDataSource(Context, Uri)</CODE></A>, or
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setDataSource(java.io.FileDescriptor, long, long)"><CODE>setDataSource(FileDescriptor, long, long)</CODE></A> transfers a
         MediaPlayer object in the <em>Idle</em> state to the
         <em>Initialized</em> state.
         <ul>
         <li>An IllegalStateException is thrown if
         setDataSource() is called in any other state.</li>
         <li>It is good programming
         practice to always look out for <code>IllegalArgumentException</code>
         and <code>IOException</code> that may be thrown from the overloaded
         <code>setDataSource</code> methods.</li>
         </ul>
         </li>
     <li>A MediaPlayer object must first enter the <em>Prepared</em> state
         before playback can be started.
         <ul>
         <li>There are two ways (synchronous vs.
         asynchronous) that the <em>Prepared</em> state can be reached:
         either a call to <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepare()"><CODE>prepare()</CODE></A> (synchronous) which
         transfers the object to the <em>Prepared</em> state once the method call
         returns, or a call to <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepareAsync()"><CODE>prepareAsync()</CODE></A> (asynchronous) which
         first transfers the object to the <em>Preparing</em> state after the
         call returns (which occurs almost right way) while the internal
         player engine continues working on the rest of preparation work
         until the preparation work completes. When the preparation completes or when <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepare()"><CODE>prepare()</CODE></A> call returns,
         the internal player engine then calls a user supplied callback method,
         onPrepared() of the OnPreparedListener interface, if an
         OnPreparedListener is registered beforehand via <CODE>#setOnPreparedListener(android.media.MediaPlayer.OnPreparedListener)</CODE>.</li>
         <li>It is important to note that
         the <em>Preparing</em> state is a transient state, and the behavior
         of calling any method with side effect while a MediaPlayer object is
         in the <em>Preparing</em> state is undefined.</li>
         <li>An IllegalStateException is
         thrown if <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepare()"><CODE>prepare()</CODE></A> or <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepareAsync()"><CODE>prepareAsync()</CODE></A> is called in
         any other state.</li>
         <li>While in the <em>Prepared</em> state, properties
         such as audio/sound volume, screenOnWhilePlaying, looping can be
         adjusted by invoking the corresponding set methods.</li>
         </ul>
         </li>
     <li>To start the playback, <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#start()"><CODE>start()</CODE></A> must be called. After
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#start()"><CODE>start()</CODE></A> returns successfully, the MediaPlayer object is in the
         <em>Started</em> state. <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#isPlaying()"><CODE>isPlaying()</CODE></A> can be called to test
         whether the MediaPlayer object is in the <em>Started</em> state.
         <ul>
         <li>While in the <em>Started</em> state, the internal player engine calls
         a user supplied OnBufferingUpdateListener.onBufferingUpdate() callback
         method if a OnBufferingUpdateListener has been registered beforehand
         via <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnBufferingUpdateListener(wseemann.media.FFmpegMediaPlayer.OnBufferingUpdateListener)"><CODE>setOnBufferingUpdateListener(OnBufferingUpdateListener)</CODE></A>.
         This callback allows applications to keep track of the buffering status
         while streaming audio/video.</li>
         <li>Calling <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#start()"><CODE>start()</CODE></A> has not effect
         on a MediaPlayer object that is already in the <em>Started</em> state.</li>
         </ul>
         </li>
     <li>Playback can be paused and stopped, and the current playback position
         can be adjusted. Playback can be paused via <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#pause()"><CODE>pause()</CODE></A>. When the call to
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#pause()"><CODE>pause()</CODE></A> returns, the MediaPlayer object enters the
         <em>Paused</em> state. Note that the transition from the <em>Started</em>
         state to the <em>Paused</em> state and vice versa happens
         asynchronously in the player engine. It may take some time before
         the state is updated in calls to <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#isPlaying()"><CODE>isPlaying()</CODE></A>, and it can be
         a number of seconds in the case of streamed content.
         <ul>
         <li>Calling <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#start()"><CODE>start()</CODE></A> to resume playback for a paused
         MediaPlayer object, and the resumed playback
         position is the same as where it was paused. When the call to
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#start()"><CODE>start()</CODE></A> returns, the paused MediaPlayer object goes back to
         the <em>Started</em> state.</li>
         <li>Calling <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#pause()"><CODE>pause()</CODE></A> has no effect on
         a MediaPlayer object that is already in the <em>Paused</em> state.</li>
         </ul>
         </li>
     <li>Calling  <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#stop()"><CODE>stop()</CODE></A> stops playback and causes a
         MediaPlayer in the <em>Started</em>, <em>Paused</em>, <em>Prepared
         </em> or <em>PlaybackCompleted</em> state to enter the
         <em>Stopped</em> state.
         <ul>
         <li>Once in the <em>Stopped</em> state, playback cannot be started
         until <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepare()"><CODE>prepare()</CODE></A> or <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepareAsync()"><CODE>prepareAsync()</CODE></A> are called to set
         the MediaPlayer object to the <em>Prepared</em> state again.</li>
         <li>Calling <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#stop()"><CODE>stop()</CODE></A> has no effect on a MediaPlayer
         object that is already in the <em>Stopped</em> state.</li>
         </ul>
         </li>
     <li>The playback position can be adjusted with a call to
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#seekTo(int)"><CODE>seekTo(int)</CODE></A>.
         <ul>
         <li>Although the asynchronuous <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#seekTo(int)"><CODE>seekTo(int)</CODE></A>
         call returns right way, the actual seek operation may take a while to
         finish, especially for audio/video being streamed. When the actual
         seek operation completes, the internal player engine calls a user
         supplied OnSeekComplete.onSeekComplete() if an OnSeekCompleteListener
         has been registered beforehand via
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnSeekCompleteListener(wseemann.media.FFmpegMediaPlayer.OnSeekCompleteListener)"><CODE>setOnSeekCompleteListener(OnSeekCompleteListener)</CODE></A>.</li>
         <li>Please
         note that <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#seekTo(int)"><CODE>seekTo(int)</CODE></A> can also be called in the other states,
         such as <em>Prepared</em>, <em>Paused</em> and <em>PlaybackCompleted
         </em> state.</li>
         <li>Furthermore, the actual current playback position
         can be retrieved with a call to <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#getCurrentPosition()"><CODE>getCurrentPosition()</CODE></A>, which
         is helpful for applications such as a Music player that need to keep
         track of the playback progress.</li>
         </ul>
         </li>
     <li>When the playback reaches the end of stream, the playback completes.
         <ul>
         <li>If the looping mode was being set to <var>true</var>with
         <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setLooping(boolean)"><CODE>setLooping(boolean)</CODE></A>, the MediaPlayer object shall remain in
         the <em>Started</em> state.</li>
         <li>If the looping mode was set to <var>false
         </var>, the player engine calls a user supplied callback method,
         OnCompletion.onCompletion(), if a OnCompletionListener is registered
         beforehand via <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnCompletionListener(wseemann.media.FFmpegMediaPlayer.OnCompletionListener)"><CODE>setOnCompletionListener(OnCompletionListener)</CODE></A>.
         The invoke of the callback signals that the object is now in the <em>
         PlaybackCompleted</em> state.</li>
         <li>While in the <em>PlaybackCompleted</em>
         state, calling <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#start()"><CODE>start()</CODE></A> can restart the playback from the
         beginning of the audio/video source.</li>
 </ul>


 <a name="Valid_and_Invalid_States"></a>
 <h3>Valid and invalid states</h3>

 <table border="0" cellspacing="0" cellpadding="0">
 <tr><td>Method Name </p></td>
     <td>Valid Sates </p></td>
     <td>Invalid States </p></td>
     <td>Comments </p></td></tr>
 <tr><td>attachAuxEffect </p></td>
     <td>{Initialized, Prepared, Started, Paused, Stopped, PlaybackCompleted} </p></td>
     <td>{Idle, Error} </p></td>
     <td>This method must be called after setDataSource.
     Calling it does not change the object state. </p></td></tr>
 <tr><td>getAudioSessionId </p></td>
     <td>any </p></td>
     <td>{} </p></td>
     <td>This method can be called in any state and calling it does not change
         the object state. </p></td></tr>
 <tr><td>getCurrentPosition </p></td>
     <td>{Idle, Initialized, Prepared, Started, Paused, Stopped,
         PlaybackCompleted} </p></td>
     <td>{Error}</p></td>
     <td>Successful invoke of this method in a valid state does not change the
         state. Calling this method in an invalid state transfers the object
         to the <em>Error</em> state. </p></td></tr>
 <tr><td>getDuration </p></td>
     <td>{Prepared, Started, Paused, Stopped, PlaybackCompleted} </p></td>
     <td>{Idle, Initialized, Error} </p></td>
     <td>Successful invoke of this method in a valid state does not change the
         state. Calling this method in an invalid state transfers the object
         to the <em>Error</em> state. </p></td></tr>
 <tr><td>getVideoHeight </p></td>
     <td>{Idle, Initialized, Prepared, Started, Paused, Stopped,
         PlaybackCompleted}</p></td>
     <td>{Error}</p></td>
     <td>Successful invoke of this method in a valid state does not change the
         state. Calling this method in an invalid state transfers the object
         to the <em>Error</em> state.  </p></td></tr>
 <tr><td>getVideoWidth </p></td>
     <td>{Idle, Initialized, Prepared, Started, Paused, Stopped,
         PlaybackCompleted}</p></td>
     <td>{Error}</p></td>
     <td>Successful invoke of this method in a valid state does not change
         the state. Calling this method in an invalid state transfers the
         object to the <em>Error</em> state. </p></td></tr>
 <tr><td>isPlaying </p></td>
     <td>{Idle, Initialized, Prepared, Started, Paused, Stopped,
          PlaybackCompleted}</p></td>
     <td>{Error}</p></td>
     <td>Successful invoke of this method in a valid state does not change
         the state. Calling this method in an invalid state transfers the
         object to the <em>Error</em> state. </p></td></tr>
 <tr><td>pause </p></td>
     <td>{Started, Paused}</p></td>
     <td>{Idle, Initialized, Prepared, Stopped, PlaybackCompleted, Error}</p></td>
     <td>Successful invoke of this method in a valid state transfers the
         object to the <em>Paused</em> state. Calling this method in an
         invalid state transfers the object to the <em>Error</em> state.</p></td></tr>
 <tr><td>prepare </p></td>
     <td>{Initialized, Stopped} </p></td>
     <td>{Idle, Prepared, Started, Paused, PlaybackCompleted, Error} </p></td>
     <td>Successful invoke of this method in a valid state transfers the
         object to the <em>Prepared</em> state. Calling this method in an
         invalid state throws an IllegalStateException.</p></td></tr>
 <tr><td>prepareAsync </p></td>
     <td>{Initialized, Stopped} </p></td>
     <td>{Idle, Prepared, Started, Paused, PlaybackCompleted, Error} </p></td>
     <td>Successful invoke of this method in a valid state transfers the
         object to the <em>Preparing</em> state. Calling this method in an
         invalid state throws an IllegalStateException.</p></td></tr>
 <tr><td>release </p></td>
     <td>any </p></td>
     <td>{} </p></td>
     <td>After <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#release()"><CODE>release()</CODE></A>, the object is no longer available. </p></td></tr>
 <tr><td>reset </p></td>
     <td>{Idle, Initialized, Prepared, Started, Paused, Stopped,
         PlaybackCompleted, Error}</p></td>
     <td>{}</p></td>
     <td>After <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#reset()"><CODE>reset()</CODE></A>, the object is like being just created.</p></td></tr>
 <tr><td>seekTo </p></td>
     <td>{Prepared, Started, Paused, PlaybackCompleted} </p></td>
     <td>{Idle, Initialized, Stopped, Error}</p></td>
     <td>Successful invoke of this method in a valid state does not change
         the state. Calling this method in an invalid state transfers the
         object to the <em>Error</em> state. </p></td></tr>
 <tr><td>setAudioSessionId </p></td>
     <td>{Idle} </p></td>
     <td>{Initialized, Prepared, Started, Paused, Stopped, PlaybackCompleted,
          Error} </p></td>
     <td>This method must be called in idle state as the audio session ID must be known before
         calling setDataSource. Calling it does not change the object state. </p></td></tr>
 <tr><td>setAudioStreamType </p></td>
     <td>{Idle, Initialized, Stopped, Prepared, Started, Paused,
          PlaybackCompleted}</p></td>
     <td>{Error}</p></td>
     <td>Successful invoke of this method does not change the state. In order for the
         target audio stream type to become effective, this method must be called before
         prepare() or prepareAsync().</p></td></tr>
 <tr><td>setAuxEffectSendLevel </p></td>
     <td>any</p></td>
     <td>{} </p></td>
     <td>Calling this method does not change the object state. </p></td></tr>
 <tr><td>setDataSource </p></td>
     <td>{Idle} </p></td>
     <td>{Initialized, Prepared, Started, Paused, Stopped, PlaybackCompleted,
          Error} </p></td>
     <td>Successful invoke of this method in a valid state transfers the
         object to the <em>Initialized</em> state. Calling this method in an
         invalid state throws an IllegalStateException.</p></td></tr>
 <tr><td>setDisplay </p></td>
     <td>any </p></td>
     <td>{} </p></td>
     <td>This method can be called in any state and calling it does not change
         the object state. </p></td></tr>
 <tr><td>setSurface </p></td>
     <td>any </p></td>
     <td>{} </p></td>
     <td>This method can be called in any state and calling it does not change
         the object state. </p></td></tr>
 <tr><td>setLooping </p></td>
     <td>{Idle, Initialized, Stopped, Prepared, Started, Paused,
         PlaybackCompleted}</p></td>
     <td>{Error}</p></td>
     <td>Successful invoke of this method in a valid state does not change
         the state. Calling this method in an
         invalid state transfers the object to the <em>Error</em> state.</p></td></tr>
 <tr><td>isLooping </p></td>
     <td>any </p></td>
     <td>{} </p></td>
     <td>This method can be called in any state and calling it does not change
         the object state. </p></td></tr>
 <tr><td>setOnBufferingUpdateListener </p></td>
     <td>any </p></td>
     <td>{} </p></td>
     <td>This method can be called in any state and calling it does not change
         the object state. </p></td></tr>
 <tr><td>setOnCompletionListener </p></td>
     <td>any </p></td>
     <td>{} </p></td>
     <td>This method can be called in any state and calling it does not change
         the object state. </p></td></tr>
 <tr><td>setOnErrorListener </p></td>
     <td>any </p></td>
     <td>{} </p></td>
     <td>This method can be called in any state and calling it does not change
         the object state. </p></td></tr>
 <tr><td>setOnPreparedListener </p></td>
     <td>any </p></td>
     <td>{} </p></td>
     <td>This method can be called in any state and calling it does not change
         the object state. </p></td></tr>
 <tr><td>setOnSeekCompleteListener </p></td>
     <td>any </p></td>
     <td>{} </p></td>
     <td>This method can be called in any state and calling it does not change
         the object state. </p></td></tr>
 <tr><td>setScreenOnWhilePlaying</></td>
     <td>any </p></td>
     <td>{} </p></td>
     <td>This method can be called in any state and calling it does not change
         the object state.  </p></td></tr>
 <tr><td>setVolume </p></td>
     <td>{Idle, Initialized, Stopped, Prepared, Started, Paused,
          PlaybackCompleted}</p></td>
     <td>{Error}</p></td>
     <td>Successful invoke of this method does not change the state.
 <tr><td>setWakeMode </p></td>
     <td>any </p></td>
     <td>{} </p></td>
     <td>This method can be called in any state and calling it does not change
         the object state.</p></td></tr>
 <tr><td>start </p></td>
     <td>{Prepared, Started, Paused, PlaybackCompleted}</p></td>
     <td>{Idle, Initialized, Stopped, Error}</p></td>
     <td>Successful invoke of this method in a valid state transfers the
         object to the <em>Started</em> state. Calling this method in an
         invalid state transfers the object to the <em>Error</em> state.</p></td></tr>
 <tr><td>stop </p></td>
     <td>{Prepared, Started, Stopped, Paused, PlaybackCompleted}</p></td>
     <td>{Idle, Initialized, Error}</p></td>
     <td>Successful invoke of this method in a valid state transfers the
         object to the <em>Stopped</em> state. Calling this method in an
         invalid state transfers the object to the <em>Error</em> state.</p></td></tr>

 </table>

 <a name="Permissions"></a>
 <h3>Permissions</h3>
 <p>One may need to declare a corresponding WAKE_LOCK permission <CODE>&lt;uses-permission&gt;</CODE>
 element.

 <p>This class requires the <CODE>android.Manifest.permission#INTERNET</CODE> permission
 when used with network-based content.

 <a name="Callbacks"></a>
 <h3>Callbacks</h3>
 <p>Applications may want to register for informational and error
 events in order to be informed of some internal state update and
 possible runtime errors during playback or streaming. Registration for
 these events is done by properly setting the appropriate listeners (via calls
 to
 <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnPreparedListener(wseemann.media.FFmpegMediaPlayer.OnPreparedListener)"><CODE>setOnPreparedListener(OnPreparedListener)</CODE></A>setOnPreparedListener,
 <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnVideoSizeChangedListener(wseemann.media.FFmpegMediaPlayer.OnVideoSizeChangedListener)"><CODE>setOnVideoSizeChangedListener(OnVideoSizeChangedListener)</CODE></A>setOnVideoSizeChangedListener,
 <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnSeekCompleteListener(wseemann.media.FFmpegMediaPlayer.OnSeekCompleteListener)"><CODE>setOnSeekCompleteListener(OnSeekCompleteListener)</CODE></A>setOnSeekCompleteListener,
 <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnCompletionListener(wseemann.media.FFmpegMediaPlayer.OnCompletionListener)"><CODE>setOnCompletionListener(OnCompletionListener)</CODE></A>setOnCompletionListener,
 <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnBufferingUpdateListener(wseemann.media.FFmpegMediaPlayer.OnBufferingUpdateListener)"><CODE>setOnBufferingUpdateListener(OnBufferingUpdateListener)</CODE></A>setOnBufferingUpdateListener,
 <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnInfoListener(wseemann.media.FFmpegMediaPlayer.OnInfoListener)"><CODE>setOnInfoListener(OnInfoListener)</CODE></A>setOnInfoListener,
 <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnErrorListener(wseemann.media.FFmpegMediaPlayer.OnErrorListener)"><CODE>setOnErrorListener(OnErrorListener)</CODE></A>setOnErrorListener, etc).
 In order to receive the respective callback
 associated with these listeners, applications are required to create
 MediaPlayer objects on a thread with its own Looper running (main UI
 thread by default has a Looper running).
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.OnBufferingUpdateListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnBufferingUpdateListener</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interface definition of a callback to be invoked indicating buffering
 status of a media resource being streamed over the network.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.OnCompletionListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnCompletionListener</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interface definition for a callback to be invoked when playback of
 a media source has completed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.OnErrorListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnErrorListener</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interface definition of a callback to be invoked when there
 has been an error during an asynchronous operation (other errors
 will throw exceptions at method call time).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.OnInfoListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnInfoListener</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interface definition of a callback to be invoked to communicate some
 info and/or warning about the media or its playback.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.OnPreparedListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnPreparedListener</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interface definition for a callback to be invoked when the media
 source is ready for playback.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.OnSeekCompleteListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnSeekCompleteListener</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interface definition of a callback to be invoked indicating
 the completion of a seek operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.OnTimedTextListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnTimedTextListener</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interface definition of a callback to be invoked when a
 timed text is available for display.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.OnVideoSizeChangedListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnVideoSizeChangedListener</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interface definition of a callback to be invoked when the
 video size is first known or updated</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#APPLY_METADATA_FILTER">APPLY_METADATA_FILTER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant to enable the metadata filter during retrieval.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#BYPASS_METADATA_FILTER">BYPASS_METADATA_FILTER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant to disable the metadata filter during retrieval.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK">MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The video is streamed and its container is not valid for progressive
 playback i.e the video's index (e.g moov atom) is not at the start of the
 file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#MEDIA_ERROR_SERVER_DIED">MEDIA_ERROR_SERVER_DIED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Media server died.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#MEDIA_ERROR_UNKNOWN">MEDIA_ERROR_UNKNOWN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unspecified media player error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#MEDIA_INFO_BAD_INTERLEAVING">MEDIA_INFO_BAD_INTERLEAVING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bad interleaving means that a media has been improperly interleaved or
 not interleaved at all, e.g has all the video samples first then all the
 audio ones.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#MEDIA_INFO_BUFFERING_END">MEDIA_INFO_BUFFERING_END</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MediaPlayer is resuming playback after filling buffers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#MEDIA_INFO_BUFFERING_START">MEDIA_INFO_BUFFERING_START</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MediaPlayer is temporarily pausing playback internally in order to
 buffer more data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#MEDIA_INFO_METADATA_UPDATE">MEDIA_INFO_METADATA_UPDATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A new set of metadata is available.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#MEDIA_INFO_NOT_SEEKABLE">MEDIA_INFO_NOT_SEEKABLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The media cannot be seeked (e.g live stream)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#MEDIA_INFO_UNKNOWN">MEDIA_INFO_UNKNOWN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unspecified media player info.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#MEDIA_INFO_VIDEO_TRACK_LAGGING">MEDIA_INFO_VIDEO_TRACK_LAGGING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The video is too complex for the decoder: it can't decode frames fast
  enough.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#METADATA_ALL">METADATA_ALL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant to retrieve all the metadata.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#METADATA_UPDATE_ONLY">METADATA_UPDATE_ONLY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant to retrieve only the new metadata since the last
       call.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#FFmpegMediaPlayer()">FFmpegMediaPlayer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default constructor.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#attachAuxEffect(int)">attachAuxEffect</A></B>(int&nbsp;effectId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attaches an auxiliary effect to the player.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../wseemann/media/FFmpegMediaPlayer.html" title="class in wseemann.media">FFmpegMediaPlayer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#create(Context, int)">create</A></B>(Context&nbsp;context,
       int&nbsp;resid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience method to create a MediaPlayer for a given resource id.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../wseemann/media/FFmpegMediaPlayer.html" title="class in wseemann.media">FFmpegMediaPlayer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#create(Context, Uri)">create</A></B>(Context&nbsp;context,
       Uri&nbsp;uri)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience method to create a MediaPlayer for a given Uri.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../wseemann/media/FFmpegMediaPlayer.html" title="class in wseemann.media">FFmpegMediaPlayer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#create(Context, Uri, SurfaceHolder)">create</A></B>(Context&nbsp;context,
       Uri&nbsp;uri,
       SurfaceHolder&nbsp;holder)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience method to create a MediaPlayer for a given Uri.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#disableTimedText()">disableTimedText</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disables timed text display.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#enableTimedText()">enableTimedText</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables the first timed text track if any.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#enableTimedTextTrackIndex(int)">enableTimedTextTrackIndex</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#finalize()">finalize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#getAudioSessionId()">getAudioSessionId</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the audio session ID.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#getCurrentPosition()">getCurrentPosition</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current playback position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#getDuration()">getDuration</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the duration of the file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;Bitmap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#getFrameAt(int)">getFrameAt</A></B>(int&nbsp;msec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#getIntParameter(int)">getIntParameter</A></B>(int&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the value of the parameter indicated by key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;Metadata</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#getMetadata(boolean, boolean)">getMetadata</A></B>(boolean&nbsp;update_only,
            boolean&nbsp;apply_filter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the media metadata.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;Parcel</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#getParcelParameter(int)">getParcelParameter</A></B>(int&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the value of the parameter indicated by key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#getStringParameter(int)">getStringParameter</A></B>(int&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the value of the parameter indicated by key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#getVideoHeight()">getVideoHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the height of the video.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#getVideoWidth()">getVideoWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the width of the video.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#invoke(Parcel, Parcel)">invoke</A></B>(Parcel&nbsp;request,
       Parcel&nbsp;reply)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invoke a generic method on the native player using opaque
 parcels for the request and reply.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#isLooping()">isLooping</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the MediaPlayer is looping or non-looping.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#isPlaying()">isPlaying</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the MediaPlayer is playing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#native_pullBatteryData(Parcel)">native_pullBatteryData</A></B>(Parcel&nbsp;reply)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;Parcel</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#newRequest()">newRequest</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a request parcel which can be routed to the native media
 player using <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#invoke(Parcel, Parcel)"><CODE>invoke(Parcel, Parcel)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#pause()">pause</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pauses playback.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepare()">prepare</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prepares the player for playback, synchronously.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepareAsync()">prepareAsync</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prepares the player for playback, asynchronously.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#release()">release</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Releases resources associated with this MediaPlayer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#reset()">reset</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resets the MediaPlayer to its uninitialized state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#seekTo(int)">seekTo</A></B>(int&nbsp;msec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Seeks to specified time position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setAudioSessionId(int)">setAudioSessionId</A></B>(int&nbsp;sessionId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the audio session ID.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setAudioStreamType(int)">setAudioStreamType</A></B>(int&nbsp;streamtype)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the audio stream type for this MediaPlayer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setAuxEffectSendLevel(float)">setAuxEffectSendLevel</A></B>(float&nbsp;level)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the send level of the player to the attached auxiliary effect
 <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#attachAuxEffect(int)"><CODE>attachAuxEffect(int)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setDataSource(Context, Uri)">setDataSource</A></B>(Context&nbsp;context,
              Uri&nbsp;uri)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the data source as a content Uri.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setDataSource(Context, Uri, java.util.Map)">setDataSource</A></B>(Context&nbsp;context,
              Uri&nbsp;uri,
              java.util.Map&lt;java.lang.String,java.lang.String&gt;&nbsp;headers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the data source as a content Uri.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setDataSource(java.io.FileDescriptor)">setDataSource</A></B>(java.io.FileDescriptor&nbsp;fd)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the data source (FileDescriptor) to use.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setDataSource(java.io.FileDescriptor, long, long)">setDataSource</A></B>(java.io.FileDescriptor&nbsp;fd,
              long&nbsp;offset,
              long&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the data source (FileDescriptor) to use.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setDataSource(java.lang.String)">setDataSource</A></B>(java.lang.String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the data source (file-path or http/rtsp URL) to use.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setDisplay(SurfaceHolder)">setDisplay</A></B>(SurfaceHolder&nbsp;sh)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <CODE>SurfaceHolder</CODE> to use for displaying the video
 portion of the media.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setLooping(boolean)">setLooping</A></B>(boolean&nbsp;looping)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the player to be looping or non-looping.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setMetadataFilter(java.util.Set, java.util.Set)">setMetadataFilter</A></B>(java.util.Set&lt;java.lang.String&gt;&nbsp;allow,
                  java.util.Set&lt;java.lang.String&gt;&nbsp;block)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set a filter for the metadata update notification and update
 retrieval.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnBufferingUpdateListener(wseemann.media.FFmpegMediaPlayer.OnBufferingUpdateListener)">setOnBufferingUpdateListener</A></B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnBufferingUpdateListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnBufferingUpdateListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register a callback to be invoked when the status of a network
 stream's buffer has changed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnCompletionListener(wseemann.media.FFmpegMediaPlayer.OnCompletionListener)">setOnCompletionListener</A></B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnCompletionListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnCompletionListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register a callback to be invoked when the end of a media source
 has been reached during playback.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnErrorListener(wseemann.media.FFmpegMediaPlayer.OnErrorListener)">setOnErrorListener</A></B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnErrorListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnErrorListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register a callback to be invoked when an error has happened
 during an asynchronous operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnInfoListener(wseemann.media.FFmpegMediaPlayer.OnInfoListener)">setOnInfoListener</A></B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnInfoListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnInfoListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register a callback to be invoked when an info/warning is available.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnPreparedListener(wseemann.media.FFmpegMediaPlayer.OnPreparedListener)">setOnPreparedListener</A></B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnPreparedListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnPreparedListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register a callback to be invoked when the media source is ready
 for playback.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnSeekCompleteListener(wseemann.media.FFmpegMediaPlayer.OnSeekCompleteListener)">setOnSeekCompleteListener</A></B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnSeekCompleteListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnSeekCompleteListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register a callback to be invoked when a seek operation has been
 completed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnTimedTextListener(wseemann.media.FFmpegMediaPlayer.OnTimedTextListener)">setOnTimedTextListener</A></B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnTimedTextListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnTimedTextListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register a callback to be invoked when a timed text is available
 for display.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnVideoSizeChangedListener(wseemann.media.FFmpegMediaPlayer.OnVideoSizeChangedListener)">setOnVideoSizeChangedListener</A></B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnVideoSizeChangedListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnVideoSizeChangedListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register a callback to be invoked when the video size is
 known or updated.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setParameter(int, Parcel)">setParameter</A></B>(int&nbsp;key,
             Parcel&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the parameter indicated by key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setScreenOnWhilePlaying(boolean)">setScreenOnWhilePlaying</A></B>(boolean&nbsp;screenOn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Control whether we should use the attached SurfaceHolder to keep the
 screen on while video playback is occurring.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setSurface(Surface)">setSurface</A></B>(Surface&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <CODE>Surface</CODE> to be used as the sink for the video portion of
 the media.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setVolume(float, float)">setVolume</A></B>(float&nbsp;leftVolume,
          float&nbsp;rightVolume)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the volume on this player.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setWakeMode(Context, int)">setWakeMode</A></B>(Context&nbsp;context,
            int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the low-level power management behavior for this MediaPlayer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#start()">start</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Starts or resumes playback.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../wseemann/media/FFmpegMediaPlayer.html#stop()">stop</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stops playback after playback has been stopped or paused.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="METADATA_UPDATE_ONLY"><!-- --></A><H3>
METADATA_UPDATE_ONLY</H3>
<PRE>
public static final boolean <B>METADATA_UPDATE_ONLY</B></PRE>
<DL>
<DD>Constant to retrieve only the new metadata since the last
       call.
       // FIXME: unhide.
       // FIXME: add link to getMetadata(boolean, boolean)
       
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#wseemann.media.FFmpegMediaPlayer.METADATA_UPDATE_ONLY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="METADATA_ALL"><!-- --></A><H3>
METADATA_ALL</H3>
<PRE>
public static final boolean <B>METADATA_ALL</B></PRE>
<DL>
<DD>Constant to retrieve all the metadata.
       // FIXME: unhide.
       // FIXME: add link to getMetadata(boolean, boolean)
       
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#wseemann.media.FFmpegMediaPlayer.METADATA_ALL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="APPLY_METADATA_FILTER"><!-- --></A><H3>
APPLY_METADATA_FILTER</H3>
<PRE>
public static final boolean <B>APPLY_METADATA_FILTER</B></PRE>
<DL>
<DD>Constant to enable the metadata filter during retrieval.
       // FIXME: unhide.
       // FIXME: add link to getMetadata(boolean, boolean)
       
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#wseemann.media.FFmpegMediaPlayer.APPLY_METADATA_FILTER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BYPASS_METADATA_FILTER"><!-- --></A><H3>
BYPASS_METADATA_FILTER</H3>
<PRE>
public static final boolean <B>BYPASS_METADATA_FILTER</B></PRE>
<DL>
<DD>Constant to disable the metadata filter during retrieval.
       // FIXME: unhide.
       // FIXME: add link to getMetadata(boolean, boolean)
       
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#wseemann.media.FFmpegMediaPlayer.BYPASS_METADATA_FILTER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MEDIA_ERROR_UNKNOWN"><!-- --></A><H3>
MEDIA_ERROR_UNKNOWN</H3>
<PRE>
public static final int <B>MEDIA_ERROR_UNKNOWN</B></PRE>
<DL>
<DD>Unspecified media player error.
<P>
<DL>
<DT><B>See Also:</B><DD><CODE>android.media.MediaPlayer.OnErrorListener</CODE>, 
<A HREF="../../constant-values.html#wseemann.media.FFmpegMediaPlayer.MEDIA_ERROR_UNKNOWN">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MEDIA_ERROR_SERVER_DIED"><!-- --></A><H3>
MEDIA_ERROR_SERVER_DIED</H3>
<PRE>
public static final int <B>MEDIA_ERROR_SERVER_DIED</B></PRE>
<DL>
<DD>Media server died. In this case, the application must release the
 MediaPlayer object and instantiate a new one.
<P>
<DL>
<DT><B>See Also:</B><DD><CODE>android.media.MediaPlayer.OnErrorListener</CODE>, 
<A HREF="../../constant-values.html#wseemann.media.FFmpegMediaPlayer.MEDIA_ERROR_SERVER_DIED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK"><!-- --></A><H3>
MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK</H3>
<PRE>
public static final int <B>MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK</B></PRE>
<DL>
<DD>The video is streamed and its container is not valid for progressive
 playback i.e the video's index (e.g moov atom) is not at the start of the
 file.
<P>
<DL>
<DT><B>See Also:</B><DD><CODE>android.media.MediaPlayer.OnErrorListener</CODE>, 
<A HREF="../../constant-values.html#wseemann.media.FFmpegMediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MEDIA_INFO_UNKNOWN"><!-- --></A><H3>
MEDIA_INFO_UNKNOWN</H3>
<PRE>
public static final int <B>MEDIA_INFO_UNKNOWN</B></PRE>
<DL>
<DD>Unspecified media player info.
<P>
<DL>
<DT><B>See Also:</B><DD><CODE>android.media.MediaPlayer.OnInfoListener</CODE>, 
<A HREF="../../constant-values.html#wseemann.media.FFmpegMediaPlayer.MEDIA_INFO_UNKNOWN">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MEDIA_INFO_VIDEO_TRACK_LAGGING"><!-- --></A><H3>
MEDIA_INFO_VIDEO_TRACK_LAGGING</H3>
<PRE>
public static final int <B>MEDIA_INFO_VIDEO_TRACK_LAGGING</B></PRE>
<DL>
<DD>The video is too complex for the decoder: it can't decode frames fast
  enough. Possibly only the audio plays fine at this stage.
<P>
<DL>
<DT><B>See Also:</B><DD><CODE>android.media.MediaPlayer.OnInfoListener</CODE>, 
<A HREF="../../constant-values.html#wseemann.media.FFmpegMediaPlayer.MEDIA_INFO_VIDEO_TRACK_LAGGING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MEDIA_INFO_BUFFERING_START"><!-- --></A><H3>
MEDIA_INFO_BUFFERING_START</H3>
<PRE>
public static final int <B>MEDIA_INFO_BUFFERING_START</B></PRE>
<DL>
<DD>MediaPlayer is temporarily pausing playback internally in order to
 buffer more data.
<P>
<DL>
<DT><B>See Also:</B><DD><CODE>android.media.MediaPlayer.OnInfoListener</CODE>, 
<A HREF="../../constant-values.html#wseemann.media.FFmpegMediaPlayer.MEDIA_INFO_BUFFERING_START">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MEDIA_INFO_BUFFERING_END"><!-- --></A><H3>
MEDIA_INFO_BUFFERING_END</H3>
<PRE>
public static final int <B>MEDIA_INFO_BUFFERING_END</B></PRE>
<DL>
<DD>MediaPlayer is resuming playback after filling buffers.
<P>
<DL>
<DT><B>See Also:</B><DD><CODE>android.media.MediaPlayer.OnInfoListener</CODE>, 
<A HREF="../../constant-values.html#wseemann.media.FFmpegMediaPlayer.MEDIA_INFO_BUFFERING_END">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MEDIA_INFO_BAD_INTERLEAVING"><!-- --></A><H3>
MEDIA_INFO_BAD_INTERLEAVING</H3>
<PRE>
public static final int <B>MEDIA_INFO_BAD_INTERLEAVING</B></PRE>
<DL>
<DD>Bad interleaving means that a media has been improperly interleaved or
 not interleaved at all, e.g has all the video samples first then all the
 audio ones. Video is playing but a lot of disk seeks may be happening.
<P>
<DL>
<DT><B>See Also:</B><DD><CODE>android.media.MediaPlayer.OnInfoListener</CODE>, 
<A HREF="../../constant-values.html#wseemann.media.FFmpegMediaPlayer.MEDIA_INFO_BAD_INTERLEAVING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MEDIA_INFO_NOT_SEEKABLE"><!-- --></A><H3>
MEDIA_INFO_NOT_SEEKABLE</H3>
<PRE>
public static final int <B>MEDIA_INFO_NOT_SEEKABLE</B></PRE>
<DL>
<DD>The media cannot be seeked (e.g live stream)
<P>
<DL>
<DT><B>See Also:</B><DD><CODE>android.media.MediaPlayer.OnInfoListener</CODE>, 
<A HREF="../../constant-values.html#wseemann.media.FFmpegMediaPlayer.MEDIA_INFO_NOT_SEEKABLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MEDIA_INFO_METADATA_UPDATE"><!-- --></A><H3>
MEDIA_INFO_METADATA_UPDATE</H3>
<PRE>
public static final int <B>MEDIA_INFO_METADATA_UPDATE</B></PRE>
<DL>
<DD>A new set of metadata is available.
<P>
<DL>
<DT><B>See Also:</B><DD><CODE>android.media.MediaPlayer.OnInfoListener</CODE>, 
<A HREF="../../constant-values.html#wseemann.media.FFmpegMediaPlayer.MEDIA_INFO_METADATA_UPDATE">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="FFmpegMediaPlayer()"><!-- --></A><H3>
FFmpegMediaPlayer</H3>
<PRE>
public <B>FFmpegMediaPlayer</B>()</PRE>
<DL>
<DD>Default constructor. Consider using one of the create() methods for
 synchronously instantiating a MediaPlayer from a Uri or resource.
 <p>When done with the MediaPlayer, you should call  <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#release()"><CODE>release()</CODE></A>,
 to free the resources. If not released, too many MediaPlayer instances may
 result in an exception.</p>
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="newRequest()"><!-- --></A><H3>
newRequest</H3>
<PRE>
public Parcel <B>newRequest</B>()</PRE>
<DL>
<DD>Create a request parcel which can be routed to the native media
 player using <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#invoke(Parcel, Parcel)"><CODE>invoke(Parcel, Parcel)</CODE></A>. The Parcel
 returned has the proper InterfaceToken set. The caller should
 not overwrite that token, i.e it can only append data to the
 Parcel.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>A parcel suitable to hold a request for the native
 player.
 </DL>
</DD>
</DL>
<HR>

<A NAME="invoke(Parcel, Parcel)"><!-- --></A><H3>
invoke</H3>
<PRE>
public int <B>invoke</B>(Parcel&nbsp;request,
                  Parcel&nbsp;reply)</PRE>
<DL>
<DD>Invoke a generic method on the native player using opaque
 parcels for the request and reply. Both payloads' format is a
 convention between the java caller and the native player.
 Must be called after setDataSource to make sure a native player
 exists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>request</CODE> - Parcel with the data for the extension. The
 caller must use <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#newRequest()"><CODE>newRequest()</CODE></A> to get one.<DD><CODE>reply</CODE> - Output parcel with the data returned by the
 native player.
<DT><B>Returns:</B><DD>The status code see utils/Errors.h
 </DL>
</DD>
</DL>
<HR>

<A NAME="setDisplay(SurfaceHolder)"><!-- --></A><H3>
setDisplay</H3>
<PRE>
public void <B>setDisplay</B>(SurfaceHolder&nbsp;sh)</PRE>
<DL>
<DD>Sets the <CODE>SurfaceHolder</CODE> to use for displaying the video
 portion of the media.

 Either a surface holder or surface must be set if a display or video sink
 is needed.  Not calling this method or <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setSurface(Surface)"><CODE>setSurface(Surface)</CODE></A>
 when playing back a video will result in only the audio track being played.
 A null surface holder or surface will result in only the audio track being
 played.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sh</CODE> - the SurfaceHolder to use for video display</DL>
</DD>
</DL>
<HR>

<A NAME="setSurface(Surface)"><!-- --></A><H3>
setSurface</H3>
<PRE>
public void <B>setSurface</B>(Surface&nbsp;surface)</PRE>
<DL>
<DD>Sets the <CODE>Surface</CODE> to be used as the sink for the video portion of
 the media. This is similar to <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setDisplay(SurfaceHolder)"><CODE>setDisplay(SurfaceHolder)</CODE></A>, but
 does not support <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setScreenOnWhilePlaying(boolean)"><CODE>setScreenOnWhilePlaying(boolean)</CODE></A>.  Setting a
 Surface will un-set any Surface or SurfaceHolder that was previously set.
 A null surface will result in only the audio track being played.

 If the Surface sends frames to a <CODE>SurfaceTexture</CODE>, the timestamps
 returned from <CODE>SurfaceTexture#getTimestamp()</CODE> will have an
 unspecified zero point.  These timestamps cannot be directly compared
 between different media sources, different instances of the same media
 source, or multiple runs of the same program.  The timestamp is normally
 monotonically increasing and is unaffected by time-of-day adjustments,
 but it is reset when the position is set.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>surface</CODE> - The <CODE>Surface</CODE> to be used for the video portion of
 the media.</DL>
</DD>
</DL>
<HR>

<A NAME="create(Context, Uri)"><!-- --></A><H3>
create</H3>
<PRE>
public static <A HREF="../../wseemann/media/FFmpegMediaPlayer.html" title="class in wseemann.media">FFmpegMediaPlayer</A> <B>create</B>(Context&nbsp;context,
                                       Uri&nbsp;uri)</PRE>
<DL>
<DD>Convenience method to create a MediaPlayer for a given Uri.
 On success, <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepare()"><CODE>prepare()</CODE></A> will already have been called and must not be called again.
 <p>When done with the MediaPlayer, you should call  <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#release()"><CODE>release()</CODE></A>,
 to free the resources. If not released, too many MediaPlayer instances will
 result in an exception.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>context</CODE> - the Context to use<DD><CODE>uri</CODE> - the Uri from which to get the datasource
<DT><B>Returns:</B><DD>a MediaPlayer object, or null if creation failed</DL>
</DD>
</DL>
<HR>

<A NAME="create(Context, Uri, SurfaceHolder)"><!-- --></A><H3>
create</H3>
<PRE>
public static <A HREF="../../wseemann/media/FFmpegMediaPlayer.html" title="class in wseemann.media">FFmpegMediaPlayer</A> <B>create</B>(Context&nbsp;context,
                                       Uri&nbsp;uri,
                                       SurfaceHolder&nbsp;holder)</PRE>
<DL>
<DD>Convenience method to create a MediaPlayer for a given Uri.
 On success, <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepare()"><CODE>prepare()</CODE></A> will already have been called and must not be called again.
 <p>When done with the MediaPlayer, you should call  <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#release()"><CODE>release()</CODE></A>,
 to free the resources. If not released, too many MediaPlayer instances will
 result in an exception.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>context</CODE> - the Context to use<DD><CODE>uri</CODE> - the Uri from which to get the datasource<DD><CODE>holder</CODE> - the SurfaceHolder to use for displaying the video
<DT><B>Returns:</B><DD>a MediaPlayer object, or null if creation failed</DL>
</DD>
</DL>
<HR>

<A NAME="create(Context, int)"><!-- --></A><H3>
create</H3>
<PRE>
public static <A HREF="../../wseemann/media/FFmpegMediaPlayer.html" title="class in wseemann.media">FFmpegMediaPlayer</A> <B>create</B>(Context&nbsp;context,
                                       int&nbsp;resid)</PRE>
<DL>
<DD>Convenience method to create a MediaPlayer for a given resource id.
 On success, <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#prepare()"><CODE>prepare()</CODE></A> will already have been called and must not be called again.
 <p>When done with the MediaPlayer, you should call  <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#release()"><CODE>release()</CODE></A>,
 to free the resources. If not released, too many MediaPlayer instances will
 result in an exception.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>context</CODE> - the Context to use<DD><CODE>resid</CODE> - the raw resource id (<var>R.raw.&lt;something></var>) for
              the resource to use as the datasource
<DT><B>Returns:</B><DD>a MediaPlayer object, or null if creation failed</DL>
</DD>
</DL>
<HR>

<A NAME="setDataSource(Context, Uri)"><!-- --></A><H3>
setDataSource</H3>
<PRE>
public void <B>setDataSource</B>(Context&nbsp;context,
                          Uri&nbsp;uri)
                   throws java.io.IOException,
                          java.lang.IllegalArgumentException,
                          java.lang.SecurityException,
                          java.lang.IllegalStateException</PRE>
<DL>
<DD>Sets the data source as a content Uri.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>context</CODE> - the Context to use when resolving the Uri<DD><CODE>uri</CODE> - the Content URI of the data you want to play
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if it is called in an invalid state
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE>
<DD><CODE>java.lang.SecurityException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setDataSource(Context, Uri, java.util.Map)"><!-- --></A><H3>
setDataSource</H3>
<PRE>
public void <B>setDataSource</B>(Context&nbsp;context,
                          Uri&nbsp;uri,
                          java.util.Map&lt;java.lang.String,java.lang.String&gt;&nbsp;headers)
                   throws java.io.IOException,
                          java.lang.IllegalArgumentException,
                          java.lang.SecurityException,
                          java.lang.IllegalStateException</PRE>
<DL>
<DD>Sets the data source as a content Uri.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>context</CODE> - the Context to use when resolving the Uri<DD><CODE>uri</CODE> - the Content URI of the data you want to play<DD><CODE>headers</CODE> - the headers to be sent together with the request for the data
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if it is called in an invalid state
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE>
<DD><CODE>java.lang.SecurityException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setDataSource(java.lang.String)"><!-- --></A><H3>
setDataSource</H3>
<PRE>
public void <B>setDataSource</B>(java.lang.String&nbsp;path)
                   throws java.io.IOException,
                          java.lang.IllegalArgumentException,
                          java.lang.SecurityException,
                          java.lang.IllegalStateException</PRE>
<DL>
<DD>Sets the data source (file-path or http/rtsp URL) to use.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>path</CODE> - the path of the file, or the http/rtsp URL of the stream you want to play
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if it is called in an invalid state

 <p>When <code>path</code> refers to a local file, the file may actually be opened by a
 process other than the calling application.  This implies that the pathname
 should be an absolute path (as any other process runs with unspecified current working
 directory), and that the pathname should reference a world-readable file.
 As an alternative, the application could first open the file for reading,
 and then use the file descriptor form <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setDataSource(java.io.FileDescriptor)"><CODE>setDataSource(FileDescriptor)</CODE></A>.
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE>
<DD><CODE>java.lang.SecurityException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setDataSource(java.io.FileDescriptor)"><!-- --></A><H3>
setDataSource</H3>
<PRE>
public void <B>setDataSource</B>(java.io.FileDescriptor&nbsp;fd)
                   throws java.io.IOException,
                          java.lang.IllegalArgumentException,
                          java.lang.IllegalStateException</PRE>
<DL>
<DD>Sets the data source (FileDescriptor) to use. It is the caller's responsibility
 to close the file descriptor. It is safe to do so as soon as this call returns.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fd</CODE> - the FileDescriptor for the file you want to play
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if it is called in an invalid state
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setDataSource(java.io.FileDescriptor, long, long)"><!-- --></A><H3>
setDataSource</H3>
<PRE>
public void <B>setDataSource</B>(java.io.FileDescriptor&nbsp;fd,
                          long&nbsp;offset,
                          long&nbsp;length)
                   throws java.io.IOException,
                          java.lang.IllegalArgumentException,
                          java.lang.IllegalStateException</PRE>
<DL>
<DD>Sets the data source (FileDescriptor) to use.  The FileDescriptor must be
 seekable (N.B. a LocalSocket is not seekable). It is the caller's responsibility
 to close the file descriptor. It is safe to do so as soon as this call returns.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fd</CODE> - the FileDescriptor for the file you want to play<DD><CODE>offset</CODE> - the offset into the file where the data to be played starts, in bytes<DD><CODE>length</CODE> - the length in bytes of the data to be played
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if it is called in an invalid state
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="prepare()"><!-- --></A><H3>
prepare</H3>
<PRE>
public void <B>prepare</B>()
             throws java.io.IOException,
                    java.lang.IllegalStateException</PRE>
<DL>
<DD>Prepares the player for playback, synchronously.

 After setting the datasource and the display surface, you need to either
 call prepare() or prepareAsync(). For files, it is OK to call prepare(),
 which blocks until MediaPlayer is ready for playback.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if it is called in an invalid state
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="prepareAsync()"><!-- --></A><H3>
prepareAsync</H3>
<PRE>
public void <B>prepareAsync</B>()
                  throws java.lang.IllegalStateException</PRE>
<DL>
<DD>Prepares the player for playback, asynchronously.

 After setting the datasource and the display surface, you need to either
 call prepare() or prepareAsync(). For streams, you should call prepareAsync(),
 which returns immediately, rather than blocking until enough data has been
 buffered.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if it is called in an invalid state</DL>
</DD>
</DL>
<HR>

<A NAME="start()"><!-- --></A><H3>
start</H3>
<PRE>
public void <B>start</B>()
           throws java.lang.IllegalStateException</PRE>
<DL>
<DD>Starts or resumes playback. If playback had previously been paused,
 playback will continue from where it was paused. If playback had
 been stopped, or never started before, playback will start at the
 beginning.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if it is called in an invalid state</DL>
</DD>
</DL>
<HR>

<A NAME="stop()"><!-- --></A><H3>
stop</H3>
<PRE>
public void <B>stop</B>()
          throws java.lang.IllegalStateException</PRE>
<DL>
<DD>Stops playback after playback has been stopped or paused.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if the internal player engine has not been
 initialized.</DL>
</DD>
</DL>
<HR>

<A NAME="pause()"><!-- --></A><H3>
pause</H3>
<PRE>
public void <B>pause</B>()
           throws java.lang.IllegalStateException</PRE>
<DL>
<DD>Pauses playback. Call start() to resume.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if the internal player engine has not been
 initialized.</DL>
</DD>
</DL>
<HR>

<A NAME="setWakeMode(Context, int)"><!-- --></A><H3>
setWakeMode</H3>
<PRE>
public void <B>setWakeMode</B>(Context&nbsp;context,
                        int&nbsp;mode)</PRE>
<DL>
<DD>Set the low-level power management behavior for this MediaPlayer.  This
 can be used when the MediaPlayer is not playing through a SurfaceHolder
 set with <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setDisplay(SurfaceHolder)"><CODE>setDisplay(SurfaceHolder)</CODE></A> and thus can use the
 high-level <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setScreenOnWhilePlaying(boolean)"><CODE>setScreenOnWhilePlaying(boolean)</CODE></A> feature.

 <p>This function has the MediaPlayer access the low-level power manager
 service to control the device's power usage while playing is occurring.
 The parameter is a combination of <CODE>android.os.PowerManager</CODE> wake flags.
 Use of this method requires <CODE>android.Manifest.permission#WAKE_LOCK</CODE>
 permission.
 By default, no attempt is made to keep the device awake during playback.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>context</CODE> - the Context to use<DD><CODE>mode</CODE> - the power/wake mode to set<DT><B>See Also:</B><DD><CODE>android.os.PowerManager</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setScreenOnWhilePlaying(boolean)"><!-- --></A><H3>
setScreenOnWhilePlaying</H3>
<PRE>
public void <B>setScreenOnWhilePlaying</B>(boolean&nbsp;screenOn)</PRE>
<DL>
<DD>Control whether we should use the attached SurfaceHolder to keep the
 screen on while video playback is occurring.  This is the preferred
 method over <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setWakeMode(Context, int)"><CODE>setWakeMode(Context, int)</CODE></A> where possible, since it doesn't
 require that the application have permission for low-level wake lock
 access.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>screenOn</CODE> - Supply true to keep the screen on, false to allow it
 to turn off.</DL>
</DD>
</DL>
<HR>

<A NAME="getVideoWidth()"><!-- --></A><H3>
getVideoWidth</H3>
<PRE>
public int <B>getVideoWidth</B>()</PRE>
<DL>
<DD>Returns the width of the video.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the width of the video, or 0 if there is no video,
 no display surface was set, or the width has not been determined
 yet. The OnVideoSizeChangedListener can be registered via
 <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnVideoSizeChangedListener(wseemann.media.FFmpegMediaPlayer.OnVideoSizeChangedListener)"><CODE>setOnVideoSizeChangedListener(OnVideoSizeChangedListener)</CODE></A>
 to provide a notification when the width is available.</DL>
</DD>
</DL>
<HR>

<A NAME="getVideoHeight()"><!-- --></A><H3>
getVideoHeight</H3>
<PRE>
public int <B>getVideoHeight</B>()</PRE>
<DL>
<DD>Returns the height of the video.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the height of the video, or 0 if there is no video,
 no display surface was set, or the height has not been determined
 yet. The OnVideoSizeChangedListener can be registered via
 <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setOnVideoSizeChangedListener(wseemann.media.FFmpegMediaPlayer.OnVideoSizeChangedListener)"><CODE>setOnVideoSizeChangedListener(OnVideoSizeChangedListener)</CODE></A>
 to provide a notification when the height is available.</DL>
</DD>
</DL>
<HR>

<A NAME="isPlaying()"><!-- --></A><H3>
isPlaying</H3>
<PRE>
public boolean <B>isPlaying</B>()</PRE>
<DL>
<DD>Checks whether the MediaPlayer is playing.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if currently playing, false otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="seekTo(int)"><!-- --></A><H3>
seekTo</H3>
<PRE>
public void <B>seekTo</B>(int&nbsp;msec)
            throws java.lang.IllegalStateException</PRE>
<DL>
<DD>Seeks to specified time position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>msec</CODE> - the offset in milliseconds from the start to seek to
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if the internal player engine has not been
 initialized</DL>
</DD>
</DL>
<HR>

<A NAME="getCurrentPosition()"><!-- --></A><H3>
getCurrentPosition</H3>
<PRE>
public int <B>getCurrentPosition</B>()</PRE>
<DL>
<DD>Gets the current playback position.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current position in milliseconds</DL>
</DD>
</DL>
<HR>

<A NAME="getDuration()"><!-- --></A><H3>
getDuration</H3>
<PRE>
public int <B>getDuration</B>()</PRE>
<DL>
<DD>Gets the duration of the file.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the duration in milliseconds</DL>
</DD>
</DL>
<HR>

<A NAME="getMetadata(boolean, boolean)"><!-- --></A><H3>
getMetadata</H3>
<PRE>
public Metadata <B>getMetadata</B>(boolean&nbsp;update_only,
                            boolean&nbsp;apply_filter)</PRE>
<DL>
<DD>Gets the media metadata.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>update_only</CODE> - controls whether the full set of available
 metadata is returned or just the set that changed since the
 last call. See <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#METADATA_UPDATE_ONLY"><CODE>METADATA_UPDATE_ONLY</CODE></A> and <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#METADATA_ALL"><CODE>METADATA_ALL</CODE></A>.<DD><CODE>apply_filter</CODE> - if true only metadata that matches the
 filter is returned. See <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#APPLY_METADATA_FILTER"><CODE>APPLY_METADATA_FILTER</CODE></A> and <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#BYPASS_METADATA_FILTER"><CODE>BYPASS_METADATA_FILTER</CODE></A>.
<DT><B>Returns:</B><DD>The metadata, possibly empty. null if an error occured.
     // FIXME: unhide.
 </DL>
</DD>
</DL>
<HR>

<A NAME="setMetadataFilter(java.util.Set, java.util.Set)"><!-- --></A><H3>
setMetadataFilter</H3>
<PRE>
public int <B>setMetadataFilter</B>(java.util.Set&lt;java.lang.String&gt;&nbsp;allow,
                             java.util.Set&lt;java.lang.String&gt;&nbsp;block)</PRE>
<DL>
<DD>Set a filter for the metadata update notification and update
 retrieval. The caller provides 2 set of metadata keys, allowed
 and blocked. The blocked set always takes precedence over the
 allowed one.
 Metadata.MATCH_ALL and Metadata.MATCH_NONE are 2 sets available as
 shorthands to allow/block all or no metadata.

 By default, there is no filter set.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>allow</CODE> - Is the set of metadata the client is interested
              in receiving new notifications for.<DD><CODE>block</CODE> - Is the set of metadata the client is not interested
              in receiving new notifications for.
<DT><B>Returns:</B><DD>The call status code.

     // FIXME: unhide.
 </DL>
</DD>
</DL>
<HR>

<A NAME="release()"><!-- --></A><H3>
release</H3>
<PRE>
public void <B>release</B>()</PRE>
<DL>
<DD>Releases resources associated with this MediaPlayer object.
 It is considered good practice to call this method when you're
 done using the MediaPlayer. For instance, whenever the Activity
 of an application is paused, this method should be invoked to
 release the MediaPlayer object. In addition to unnecessary resources
 (such as memory and instances of codecs) being hold, failure to
 call this method immediately if a MediaPlayer object is no longer
 needed may also lead to continuous battery consumption for mobile
 devices, and playback failure if no multiple instances of the
 same codec is supported on a device.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reset()"><!-- --></A><H3>
reset</H3>
<PRE>
public void <B>reset</B>()</PRE>
<DL>
<DD>Resets the MediaPlayer to its uninitialized state. After calling
 this method, you will have to initialize it again by setting the
 data source and calling prepare().
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAudioStreamType(int)"><!-- --></A><H3>
setAudioStreamType</H3>
<PRE>
public void <B>setAudioStreamType</B>(int&nbsp;streamtype)</PRE>
<DL>
<DD>Sets the audio stream type for this MediaPlayer. See <CODE>AudioManager</CODE>
 for a list of stream types. Must call this method before prepare() or
 prepareAsync() in order for the target stream type to become effective
 thereafter.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>streamtype</CODE> - the audio stream type<DT><B>See Also:</B><DD><CODE>android.media.AudioManager</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setLooping(boolean)"><!-- --></A><H3>
setLooping</H3>
<PRE>
public void <B>setLooping</B>(boolean&nbsp;looping)</PRE>
<DL>
<DD>Sets the player to be looping or non-looping.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>looping</CODE> - whether to loop or not</DL>
</DD>
</DL>
<HR>

<A NAME="isLooping()"><!-- --></A><H3>
isLooping</H3>
<PRE>
public boolean <B>isLooping</B>()</PRE>
<DL>
<DD>Checks whether the MediaPlayer is looping or non-looping.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if the MediaPlayer is currently looping, false otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="setVolume(float, float)"><!-- --></A><H3>
setVolume</H3>
<PRE>
public void <B>setVolume</B>(float&nbsp;leftVolume,
                      float&nbsp;rightVolume)</PRE>
<DL>
<DD>Sets the volume on this player.
 This API is recommended for balancing the output of audio streams
 within an application. Unless you are writing an application to
 control user settings, this API should be used in preference to
 <CODE>AudioManager#setStreamVolume(int, int, int)</CODE> which sets the volume of ALL streams of
 a particular type. Note that the passed volume values are raw scalars.
 UI controls should be scaled logarithmically.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>leftVolume</CODE> - left volume scalar<DD><CODE>rightVolume</CODE> - right volume scalar</DL>
</DD>
</DL>
<HR>

<A NAME="getFrameAt(int)"><!-- --></A><H3>
getFrameAt</H3>
<PRE>
public Bitmap <B>getFrameAt</B>(int&nbsp;msec)
                  throws java.lang.IllegalStateException</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I></I>
<P>
<DD>Currently not implemented, returns null.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setAudioSessionId(int)"><!-- --></A><H3>
setAudioSessionId</H3>
<PRE>
public void <B>setAudioSessionId</B>(int&nbsp;sessionId)
                       throws java.lang.IllegalArgumentException,
                              java.lang.IllegalStateException</PRE>
<DL>
<DD>Sets the audio session ID.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sessionId</CODE> - the audio session ID.
 The audio session ID is a system wide unique identifier for the audio stream played by
 this MediaPlayer instance.
 The primary use of the audio session ID  is to associate audio effects to a particular
 instance of MediaPlayer: if an audio session ID is provided when creating an audio effect,
 this effect will be applied only to the audio content of media players within the same
 audio session and not to the output mix.
 When created, a MediaPlayer instance automatically generates its own audio session ID.
 However, it is possible to force this player to be part of an already existing audio session
 by calling this method.
 This method must be called before one of the overloaded <code> setDataSource </code> methods.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if it is called in an invalid state
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getAudioSessionId()"><!-- --></A><H3>
getAudioSessionId</H3>
<PRE>
public int <B>getAudioSessionId</B>()</PRE>
<DL>
<DD>Returns the audio session ID.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the audio session ID. <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setAudioSessionId(int)"><CODE>setAudioSessionId(int)</CODE></A>
 Note that the audio session ID is 0 only if a problem occured when the MediaPlayer was contructed.</DL>
</DD>
</DL>
<HR>

<A NAME="attachAuxEffect(int)"><!-- --></A><H3>
attachAuxEffect</H3>
<PRE>
public void <B>attachAuxEffect</B>(int&nbsp;effectId)</PRE>
<DL>
<DD>Attaches an auxiliary effect to the player. A typical auxiliary effect is a reverberation
 effect which can be applied on any sound source that directs a certain amount of its
 energy to this effect. This amount is defined by setAuxEffectSendLevel().
 <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#setAuxEffectSendLevel(float)"><CODE>setAuxEffectSendLevel(float)</CODE></A>.
 <p>After creating an auxiliary effect (e.g.
 <CODE>android.media.audiofx.EnvironmentalReverb</CODE>), retrieve its ID with
 <CODE>android.media.audiofx.AudioEffect#getId()</CODE> and use it when calling this method
 to attach the player to the effect.
 <p>To detach the effect from the player, call this method with a null effect id.
 <p>This method must be called after one of the overloaded <code> setDataSource </code>
 methods.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>effectId</CODE> - system wide unique id of the effect to attach</DL>
</DD>
</DL>
<HR>

<A NAME="setParameter(int, Parcel)"><!-- --></A><H3>
setParameter</H3>
<PRE>
public boolean <B>setParameter</B>(int&nbsp;key,
                            Parcel&nbsp;value)</PRE>
<DL>
<DD>Sets the parameter indicated by key.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - key indicates the parameter to be set.<DD><CODE>value</CODE> - value of the parameter to be set.
<DT><B>Returns:</B><DD>true if the parameter is set successfully, false otherwise
 </DL>
</DD>
</DL>
<HR>

<A NAME="getParcelParameter(int)"><!-- --></A><H3>
getParcelParameter</H3>
<PRE>
public Parcel <B>getParcelParameter</B>(int&nbsp;key)</PRE>
<DL>
<DD>Gets the value of the parameter indicated by key.
 The caller is responsible for recycling the returned parcel.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - key indicates the parameter to get.
<DT><B>Returns:</B><DD>value of the parameter.
 </DL>
</DD>
</DL>
<HR>

<A NAME="getStringParameter(int)"><!-- --></A><H3>
getStringParameter</H3>
<PRE>
public java.lang.String <B>getStringParameter</B>(int&nbsp;key)</PRE>
<DL>
<DD>Gets the value of the parameter indicated by key.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - key indicates the parameter to get.
<DT><B>Returns:</B><DD>value of the parameter.
 </DL>
</DD>
</DL>
<HR>

<A NAME="getIntParameter(int)"><!-- --></A><H3>
getIntParameter</H3>
<PRE>
public int <B>getIntParameter</B>(int&nbsp;key)</PRE>
<DL>
<DD>Gets the value of the parameter indicated by key.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - key indicates the parameter to get.
<DT><B>Returns:</B><DD>value of the parameter.
 </DL>
</DD>
</DL>
<HR>

<A NAME="setAuxEffectSendLevel(float)"><!-- --></A><H3>
setAuxEffectSendLevel</H3>
<PRE>
public void <B>setAuxEffectSendLevel</B>(float&nbsp;level)</PRE>
<DL>
<DD>Sets the send level of the player to the attached auxiliary effect
 <A HREF="../../wseemann/media/FFmpegMediaPlayer.html#attachAuxEffect(int)"><CODE>attachAuxEffect(int)</CODE></A>. The level value range is 0 to 1.0.
 <p>By default the send level is 0, so even if an effect is attached to the player
 this method must be called for the effect to be applied.
 <p>Note that the passed level value is a raw scalar. UI controls should be scaled
 logarithmically: the gain applied by audio framework ranges from -72dB to 0dB,
 so an appropriate conversion from linear UI input x to level is:
 x == 0 -> level = 0
 0 < x <= R -> level = 10^(72*(x-R)/20/R)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>level</CODE> - send level scalar</DL>
</DD>
</DL>
<HR>

<A NAME="enableTimedTextTrackIndex(int)"><!-- --></A><H3>
enableTimedTextTrackIndex</H3>
<PRE>
public boolean <B>enableTimedTextTrackIndex</B>(int&nbsp;index)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - The index of the text track to be turned on.
<DT><B>Returns:</B><DD>true if the text track is enabled successfully.
 </DL>
</DD>
</DL>
<HR>

<A NAME="enableTimedText()"><!-- --></A><H3>
enableTimedText</H3>
<PRE>
public boolean <B>enableTimedText</B>()</PRE>
<DL>
<DD>Enables the first timed text track if any.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if the text track is enabled successfully
 </DL>
</DD>
</DL>
<HR>

<A NAME="disableTimedText()"><!-- --></A><H3>
disableTimedText</H3>
<PRE>
public boolean <B>disableTimedText</B>()</PRE>
<DL>
<DD>Disables timed text display.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if the text track is disabled successfully.
 </DL>
</DD>
</DL>
<HR>

<A NAME="native_pullBatteryData(Parcel)"><!-- --></A><H3>
native_pullBatteryData</H3>
<PRE>
public static int <B>native_pullBatteryData</B>(Parcel&nbsp;reply)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reply</CODE> - Parcel with audio/video duration info for battery
                    tracking usage
<DT><B>Returns:</B><DD>The status code.
 </DL>
</DD>
</DL>
<HR>

<A NAME="finalize()"><!-- --></A><H3>
finalize</H3>
<PRE>
protected void <B>finalize</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>finalize</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOnPreparedListener(wseemann.media.FFmpegMediaPlayer.OnPreparedListener)"><!-- --></A><H3>
setOnPreparedListener</H3>
<PRE>
public void <B>setOnPreparedListener</B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnPreparedListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnPreparedListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Register a callback to be invoked when the media source is ready
 for playback.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the callback that will be run</DL>
</DD>
</DL>
<HR>

<A NAME="setOnCompletionListener(wseemann.media.FFmpegMediaPlayer.OnCompletionListener)"><!-- --></A><H3>
setOnCompletionListener</H3>
<PRE>
public void <B>setOnCompletionListener</B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnCompletionListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnCompletionListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Register a callback to be invoked when the end of a media source
 has been reached during playback.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the callback that will be run</DL>
</DD>
</DL>
<HR>

<A NAME="setOnBufferingUpdateListener(wseemann.media.FFmpegMediaPlayer.OnBufferingUpdateListener)"><!-- --></A><H3>
setOnBufferingUpdateListener</H3>
<PRE>
public void <B>setOnBufferingUpdateListener</B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnBufferingUpdateListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnBufferingUpdateListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Register a callback to be invoked when the status of a network
 stream's buffer has changed.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the callback that will be run.</DL>
</DD>
</DL>
<HR>

<A NAME="setOnSeekCompleteListener(wseemann.media.FFmpegMediaPlayer.OnSeekCompleteListener)"><!-- --></A><H3>
setOnSeekCompleteListener</H3>
<PRE>
public void <B>setOnSeekCompleteListener</B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnSeekCompleteListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnSeekCompleteListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Register a callback to be invoked when a seek operation has been
 completed.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the callback that will be run</DL>
</DD>
</DL>
<HR>

<A NAME="setOnVideoSizeChangedListener(wseemann.media.FFmpegMediaPlayer.OnVideoSizeChangedListener)"><!-- --></A><H3>
setOnVideoSizeChangedListener</H3>
<PRE>
public void <B>setOnVideoSizeChangedListener</B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnVideoSizeChangedListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnVideoSizeChangedListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Register a callback to be invoked when the video size is
 known or updated.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the callback that will be run</DL>
</DD>
</DL>
<HR>

<A NAME="setOnTimedTextListener(wseemann.media.FFmpegMediaPlayer.OnTimedTextListener)"><!-- --></A><H3>
setOnTimedTextListener</H3>
<PRE>
public void <B>setOnTimedTextListener</B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnTimedTextListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnTimedTextListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Register a callback to be invoked when a timed text is available
 for display.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the callback that will be run
 </DL>
</DD>
</DL>
<HR>

<A NAME="setOnErrorListener(wseemann.media.FFmpegMediaPlayer.OnErrorListener)"><!-- --></A><H3>
setOnErrorListener</H3>
<PRE>
public void <B>setOnErrorListener</B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnErrorListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnErrorListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Register a callback to be invoked when an error has happened
 during an asynchronous operation.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the callback that will be run</DL>
</DD>
</DL>
<HR>

<A NAME="setOnInfoListener(wseemann.media.FFmpegMediaPlayer.OnInfoListener)"><!-- --></A><H3>
setOnInfoListener</H3>
<PRE>
public void <B>setOnInfoListener</B>(<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnInfoListener.html" title="interface in wseemann.media">FFmpegMediaPlayer.OnInfoListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Register a callback to be invoked when an info/warning is available.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the callback that will be run</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../wseemann/media/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../wseemann/media/FFmpegMediaPlayer.OnBufferingUpdateListener.html" title="interface in wseemann.media"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?wseemann/media/FFmpegMediaPlayer.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="FFmpegMediaPlayer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
